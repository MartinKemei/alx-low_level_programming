# 0x03. C - Debugging

![](https://static.javatpoint.com/blog/images/debugging2.png)

## What is debugging?
The process of finding and fixing errors in software and web apps. The errors are what are reffered to as _bugs_ by software developers. The words _'bug'_ and _'debugging'_ were coined by __Admiral Grace Hoper__ who wrote the first compiler that ever existed.

## Manual methods of debugging
Manual debugging refers to the process of identifying and fixing issues in code by analyzing its behavior, without relying on automated debugging tools. Here are some common methods for manual debugging:

- **Print Statements:** Inserting print statements at various points in the code can help you track the flow of execution and the values of variables. Print statements allow you to observe the intermediate states of your program and identify any unexpected behavior or incorrect values.

- **Code Review:** Review your code line by line, paying close attention to the logic and variable assignments. Look for any potential mistakes, typos, or incorrect assumptions. A fresh perspective and careful scrutiny can often reveal errors that may have been overlooked.

- **Divide and Conquer:** If you have a large codebase, try narrowing down the issue by systematically disabling or isolating sections of the code. By selectively commenting out parts of the code, you can identify the specific section where the problem occurs and focus your debugging efforts there.

- **Trace Execution:** Mentally trace the execution of the code, following the control flow and variable values. Pay attention to conditional statements, loops, and function calls. Verify that the program executes as intended and that variables hold the expected values.

- **Input Validation:** Check if the input values are valid and within the expected range. Validate user input and ensure that it matches the expected data type. Incorrect or unexpected input can lead to program errors, so validating inputs is an important debugging step.

- **Code Isolation:** If possible, try to isolate the problematic code by creating a minimal, self-contained example that reproduces the issue. By reducing the code to its core elements, you can focus on the specific problem without being distracted by unrelated parts.

- **Rubber Duck Debugging:** Explain your code and the problem you're facing to an inanimate object like a rubber duck. By verbalizing the problem, you might gain new insights and find a solution. This technique helps to clarify your thoughts and forces you to approach the problem from a different perspective.

- **Manual Testing:** Test different scenarios and inputs manually to observe the behavior of your code. Try to identify specific inputs or conditions that trigger the issue. This process can help you narrow down the problem and understand its underlying causes.

- **Code Inspection:** Thoroughly review your code, paying attention to variables, loops, conditional statements, and function calls. Look for potential logical errors, missing or incorrect conditions, and inconsistent variable states.

- **Debugging by Hypothesis:** Formulate hypotheses about the cause of the issue based on your understanding of the code and its behavior. Test each hypothesis systematically to verify or refute it. This approach can help you narrow down the potential causes and guide your debugging efforts.

Remember, manual debugging can be time-consuming and challenging, especially for complex issues. Using an integrated development environment (IDE) with built-in debugging tools or specialized debuggers can significantly simplify the debugging process.

## GCC flags and their use in debugging
GCC (GNU Compiler Collection) is a popular compiler suite used for compiling programs written in languages such as C, C++, and Fortran. It provides various command-line options, also known as flags, to control the behavior of the compiler. Here are some commonly used GCC flags:

- **-o** <output>: Specifies the name of the output file generated by the compiler. For example, -o program will produce an executable file named "program".

- **-c:** Compiles the source file(s) without linking, generating object file(s) instead. This flag is useful when you want to compile code separately and then link it later.

- **-g:** Includes debugging information in the compiled program. This flag allows you to use debugging tools to analyze and debug your code effectively.

- **-Wall:** Enables a set of warning messages about potentially problematic code constructs. It's recommended to use this flag to catch potential issues and improve code quality.

- **-Werror:** Treats warnings as errors, causing the compiler to halt if any warnings are encountered. This flag helps enforce strict code quality standards.

- **-std=<standard>:** Sets the language standard to be used for compilation. For example, -std=c11 sets the C11 standard, -std=c++17 sets the C++17 standard, etc.

- **-I<directory>:** Specifies additional directories to search for header files. Use this flag when your source files include headers located in non-standard locations.

- **-L<directory>:** Adds directories to the library search path. This flag allows the linker to find libraries located in non-standard locations.

- **-l<library>:** Links the program with the specified library during the linking phase. For example, -lm links with the math library.

- **-O<level>:** Enables compiler optimizations. The <level> can be a value from 0 to 3, where higher levels provide more aggressive optimizations. For example, -O2 enables moderate optimization.

These are just a few examples of commonly used GCC flags. The GCC documentation provides a comprehensive list of available flags along with detailed descriptions of their usage. You can access the documentation online or by using the command man gcc in a terminal to view the manual pages.





